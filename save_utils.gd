# save_utils.gd
# This file is part of I, Voyager
# https://ivoyager.dev
# *****************************************************************************
# Copyright 2017-2023 Charlie Whitfield
# I, Voyager is a registered trademark of Charlie Whitfield in the US
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# *****************************************************************************
class_name IVSaveUtils
extends Object

## Static utility class that provides methods related to game save/load and
## object 'persist' properties.
##
## See [IVTreeSaver] for explanation of tree persistence.

enum PersistMode {
	NO_PERSIST, ## Non-persist object.
	PERSIST_PROPERTIES_ONLY, ## Object will not be freed (Node only; must have stable NodePath).
	PERSIST_PROCEDURAL, ## Object will be freed and rebuilt on game load (Node or RefCounted).
}

const NO_PERSIST := PersistMode.NO_PERSIST
const PERSIST_PROPERTIES_ONLY := PersistMode.PERSIST_PROPERTIES_ONLY
const PERSIST_PROCEDURAL := PersistMode.PERSIST_PROCEDURAL

## A static list of names of the constants that define persist properties in a
## persist object. In base configuration these are [param &"PERSIST_PROPERTIES"]
## and [param &"PERSIST_PROPERTIES2"]. The extra list name is provided for
## subclassing.
static var persist_property_lists: Array[StringName] = [
	&"PERSIST_PROPERTIES",
	&"PERSIST_PROPERTIES2",
]


## See [method IVTreeSaver.free_procedural_objects_recursive].
static func free_procedural_objects_recursive(root_node: Node) -> void:
	_null_procedural_references_recursive(root_node, {})
	free_procedural_nodes_recursive(root_node)


## Frees all procedural [Node]s at or below [param root_node]. Note:
## [method free_procedural_objects_recursive] provides a more thorough deconstruction
## that can handle circular [RefCounted] references.
static func free_procedural_nodes_recursive(root_node: Node) -> void:
	if is_procedural_object(root_node):
		root_node.queue_free() # children will also be freed!
		return
	for child in root_node.get_children():
		if is_persist_object(child):
			free_procedural_nodes_recursive(child)


## Clones object properties using [member persist_property_lists] in the
## [param origin] class. [param origin] and [param clone] must have the same
## persist properties. Arrays and Dictionaries are duplicated (deep = true).
## However, Objects will be set without duplication.
static func clone_persist_properties(origin: Object, clone: Object) -> void:
	for properties_array in persist_property_lists:
		if not properties_array in origin:
			continue
		var properties: Array[StringName] = origin.get(properties_array)
		for property in properties:
			var value: Variant = origin.get(property)
			var type := typeof(value)
			if type == TYPE_ARRAY:
				var origin_array: Array = value
				value = origin_array.duplicate(true)
			elif type == TYPE_DICTIONARY:
				var origin_dict: Dictionary = value
				value = origin_dict.duplicate(true)
			clone.set(property, value)


## Generates an array of persist property values from [param object] using
## [member persist_property_lists]. Using this method in combination with
## [method set_persist_properties] is equivalent to [method clone_persist_properties].
static func get_persist_properties(origin: Object) -> Array:
	var array := []
	for properties_array in persist_property_lists:
		if not properties_array in origin:
			continue
		var properties: Array[StringName] = origin.get(properties_array)
		for property in properties:
			var value: Variant = origin.get(property)
			var type := typeof(value)
			if type == TYPE_ARRAY:
				var origin_array: Array = value
				value = origin_array.duplicate(true)
			elif type == TYPE_DICTIONARY:
				var origin_dict: Dictionary = value
				value = origin_dict.duplicate(true)
			array.append(value)
	return array


## Sets properties from an array generated by [method get_persist_properties].
static func set_persist_properties(clone: Object, array: Array) -> void:
	var i := 0
	for properties_array in persist_property_lists:
		if not properties_array in clone:
			continue
		var properties: Array[StringName] = clone.get(properties_array)
		for property in properties:
			clone.set(property, array[i])
			i += 1


## Generates an array of persist property names in [param object] using
## [member persist_property_lists].
static func get_persist_property_names(object: Object) -> Array[StringName]:
	var array: Array[StringName] = []
	for properties_array in persist_property_lists:
		if not properties_array in object:
			continue
		var properties: Array[StringName] = object.get(properties_array)
		array.append_array(properties)
	return array


## Returns one of [enum PersistMode] enums. Returns [enum PersistMode.NO_PERSIST]
## if [param object] does not have member [param PERSIST_MODE] or
## [param persist_mode_override].
static func get_persist_mode(object: Object) -> PersistMode:
	if &"persist_mode_override" in object:
		return object.get(&"persist_mode_override")
	if &"PERSIST_MODE" in object:
		return object.get(&"PERSIST_MODE")
	return NO_PERSIST


## Returns true if [param object] is [enum PersistMode.PERSIST_PROPERTIES_ONLY]
## or [enum PersistMode.PERSIST_PROCEDURAL], otherwise false.
static func is_persist_object(object: Object) -> bool:
	if &"persist_mode_override" in object:
		return object.get(&"persist_mode_override") != NO_PERSIST
	if &"PERSIST_MODE" in object:
		return object.get(&"PERSIST_MODE") != NO_PERSIST
	return false


## Returns true if [param object] is [enum PersistMode.PERSIST_PROCEDURAL],
## otherwise false.
static func is_procedural_object(object: Object) -> bool:
	if &"persist_mode_override" in object:
		return object.get(&"persist_mode_override") == PERSIST_PROCEDURAL
	if &"PERSIST_MODE" in object:
		return object.get(&"PERSIST_MODE") == PERSIST_PROCEDURAL
	return false


## Returns an instantiated [Object] or the root [Node] of an instantiated scene.[br][br]
##
## [param arg] can be a [Script], [PackedScene], or [String]. If it is a String,
## it must be a valid path to a Script or PackedScene file resource.[br][br]
##
## If the supplied Script or file-loaded Script has constant [param SCENE] or
## [param SCENE_OVERRIDE], then the constant value is used as path to
## instantiate a scene. 
static func make_object_or_scene(arg: Variant) -> Object:
	var arg_type := typeof(arg)
	var packedscene: PackedScene
	var script: Script
	if arg_type == TYPE_OBJECT:
		if arg is Script:
			script = arg
		elif arg is PackedScene:
			packedscene = arg
		else:
			assert(false, "Unknown object class %s" % arg)
			return null
	else:
		assert(arg is String)
		var path: String = arg
		var script_or_packedscene := get_script_or_packedscene(path)
		if !script_or_packedscene:
			assert(false, "Could not load '%s' as Script or PackedScene" % path)
			return null
		if script_or_packedscene is Script:
			script = script_or_packedscene
		else:
			packedscene = script_or_packedscene
	
	if script:
		var scene_path: String
		if &"SCENE_OVERRIDE" in script:
			scene_path = script.get("SCENE_OVERRIDE")
		elif &"SCENE" in script:
			scene_path = script.get("SCENE")
		if scene_path:
			packedscene = load(scene_path)
			if !packedscene:
				assert(false, "Failed to load scene at '%s'" % scene_path)
				return null
		else:
			@warning_ignore("unsafe_method_access")
			return script.new()
	
	var root_node: Node = packedscene.instantiate()
	if root_node.get_script() != script: # root_node.script may be parent class!
		root_node.set_script(script)
	return root_node

## Returns either a Script or a PackedScene, depending on [param path] file
## extension. Throws error if it fails to load [param path].
static func get_script_or_packedscene(path: String) -> Resource:
	if !path:
		assert(false, "Requires path")
		return null
	if path.ends_with(".tscn") or path.ends_with(".scn"):
		var packedscene: PackedScene = load(path)
		assert(packedscene, "Failed to load PackedScene at '%s'" % path)
		return packedscene
	var script: Script = load(path)
	assert(script, "Failed to load Script at '%s'" % path)
	return script



# logging
static var _log_count_by_class := {}

## Call before save and after load for a debug log. Delay the post-load call if
## the loaded objects build additional tree items.
static func get_tree_debug_log(save_root: Node, compare_class_count: bool,
		log_persist_nodes := true, log_all_nodes := false,
		print_stray_nodes := false, print_tree := false) -> PackedStringArray:
	
	var debug_log := PackedStringArray()
	var count := 0
	
	debug_log.append("Number tree nodes: %s" % save_root.get_tree().get_node_count())
	
	if print_stray_nodes:
		print("Stray Nodes:")
		save_root.print_orphan_nodes()
		print("***********************")
	if print_tree:
		print("Tree:")
		save_root.print_tree_pretty()
		print("***********************")
	
	if log_all_nodes or log_persist_nodes:
		var last_log_count_by_class: Dictionary
		if _log_count_by_class and compare_class_count:
			last_log_count_by_class = _log_count_by_class.duplicate()
		_log_count_by_class.clear()
		count = _log_nodes(save_root, log_all_nodes, debug_log, count)
		if last_log_count_by_class:
			debug_log.append("Class counts difference from last count:")
			for class_: String in _log_count_by_class:
				if last_log_count_by_class.has(class_):
					debug_log.append("%s %s" % [class_, _log_count_by_class[class_] - last_log_count_by_class[class_]])
				else:
					debug_log.append("%s %s" % [class_, _log_count_by_class[class_]])
			for class_: String in last_log_count_by_class:
				if !_log_count_by_class.has(class_):
					debug_log.append("%s %s" % [class_, -last_log_count_by_class[class_]])
		else:
			debug_log.append("Class counts:")
			for class_: String in _log_count_by_class:
				debug_log.append("%s %s" % [class_, _log_count_by_class[class_]])
	
	return debug_log


static func _log_nodes(node: Node, log_all_nodes: bool, debug_log: PackedStringArray, count: int) -> int:
	count += 1
	var class_ := node.get_class()
	if _log_count_by_class.has(class_):
		_log_count_by_class[class_] += 1
	else:
		_log_count_by_class[class_] = 1
	var script_identifier := ""
	if node.get_script():
		@warning_ignore("unsafe_method_access")
		var source_code: String = node.get_script().get_source_code()
		if source_code:
			var split := source_code.split("\n", false, 1)
			script_identifier = split[0]
	debug_log.append("%s %s %s %s" % [count, node, node.name, script_identifier])
	for child in node.get_children():
		if log_all_nodes or is_procedural_object(child):
			count = _log_nodes(child, log_all_nodes, debug_log, count)
	
	return count


static func _null_procedural_references_recursive(object: Object, nulled: Dictionary) -> void:
	# Don't process circular references.
	if nulled.has(object):
		return
	nulled[object] = true
	
	# Recursive call to all nodes. All procedural nodes must be in the tree!
	if object is Node:
		var node: Node = object
		for child in node.get_children():
			if is_persist_object(child):
				_null_procedural_references_recursive(child, nulled)
	
	# Null all procedural object references with recursive calls to RefCounteds
	for properties_array_name in persist_property_lists:
		if not properties_array_name in object:
			continue
		var properties_array: Array = object.get(properties_array_name)
		for property: StringName in properties_array:
			var value: Variant = object.get(property)
			var type := typeof(value)
			if type == TYPE_OBJECT:
				var property_object: Object = value
				_null_procedural_references_recursive(property_object, nulled)
				object.set(property, null)
			elif type == TYPE_ARRAY:
				# test elements if Object-typed only
				var array: Array = value
				if array.get_typed_builtin() == TYPE_OBJECT:
					for i in array.size():
						var array_object: Object = array[i]
						_null_procedural_references_recursive(array_object, nulled)
						array[i] = null
			elif type == TYPE_DICTIONARY:
				# test all keys and values
				var dict: Dictionary = value
				for key: Variant in dict.keys():
					var dict_value: Variant = dict[key]
					if typeof(dict_value) == TYPE_OBJECT:
						var value_object: Object = dict_value
						_null_procedural_references_recursive(value_object, nulled)
						dict[key] = null
					if typeof(key) == TYPE_OBJECT:
						var key_object: Object = key
						_null_procedural_references_recursive(key_object, nulled)
						dict.erase(key)

